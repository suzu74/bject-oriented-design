# オブジェクト指向設計ガイドメモ

## 20200102

### 第1章 オブジェクト指向設計

* オブジェクト指向設計の手法を学ぶにあたり第一の要求されることはその世界に没入すること。
* 設計の失敗の原因はコーディングテクニックではなく、視点の置き方

#### 1.1 設計の賞賛

* オブジェクト指向設計の手法に従うことで、費用対効果の高いソフトウェアを生み出せるだけでなく、楽しく取り組めるコードが実現できる

##### 設計が解決する問題

* 仮にこれから作るアプリが変更することがないアプリなら設計のことを気にする必要はない
    * ただ実際は変化は避けられない
        * この変化が計画に影響を及ぼすので、設計を重要になる
            * 変更が簡単なアプリは書くのも楽しい

##### 変更が困難な理由

* オブジェクト指向設計とは「依存関係を管理すること」
     * オブジェクトが変更を許容できるような形で、依存関係を構成するためのコーディングテクニックである。
        * 依存関係が管理されていないとオブジェクトが互いを知りすぎるので、１つの変更がもう１つへも影響し、そしてそこからさらに影響し、、、

##### 設計の実用的な定義

* 設計が難しい理由の１つは、ずべての問題を２つの要素を抱えている点
    * 今必要なコードを書くだけでなく、未来の変更も受け入れるものを作ること
         * 設計の目的は後にも設計できるようにすることで、最初の目標は変更コストの削減

#### 1.2 設計の道具

##### 設計原則

* オブジェクト指向で有名な５つの原則
    * 単一責任
    * オープンクローズド
    * リスコフの置換
    * インターフェース分離
    * 依存性逆転

 ##### 設計パターン

 * 共通する問題に同じ名前をつけ同じ手法絵で解決することで、曖昧なことが明確になる。
    * コミュニケーションと共同作業ができるようになった
        * ただし、正しく使うことが大事

####　1.3 設計の行為

##### 設計が失敗する原因

* 最初の失敗の原因は設計が十分ではないこと。
* Rubyのような言語では、誰でも動くアプリは作れるが、設計されていないアプリになるため次第に変更ができなくなる。
* 別の失敗は手法は知ってるが、その適用方法がわからない場合
    * 不適切な場所に不適切な設計をしてしまうことも、、、

##### 設計をいつ行うか

* オブジェクト指向設計とは、変更を簡単になるようにコードの構成を考えること
* アジャイルが成功する鍵がシンプルで、柔軟性のあるコードである

##### 設計を判断する

* 設計者の目標は機能あたりのコストが最も低い方法でソフトウェアを書くこと

#### 1.4 簡単な導入

* オブジェクト指向のアプリはオブジェクトとオブジェクトのメッセージから構成される
    * メッセージがより重要

##### 手続き型言語

* 手続き型プログラミングと対比させることで理解が進む
* 手続き型ではデータの種類があらかじめ決められている
    * どんなことができるかは、プログラマーがそのデータ型に対する知識に基づく

##### オブジェクト指向言語

* Rubyはデータと振る舞いを２つの独立したものにわけない
    * その２つをオブジェクトにまとめる
* 文字列のデータ型ではなく、文字列オブジェクトがある
    * 文字列オブジェクトは自身の操作は自身で用意する
        * Rubyに必要なのはオブジェクトがメッセージを送るための方法を用意することだけ
* 例）Stringクラスから作られたインスタンスはどれも同じメソッドを持つがデータは異なる
* Rubyではあらかじめstringなどのクラスが定義されている
    * そのstringクラスもそれ自体がオブジェクト、Classクラスのインスタンス
        * Stringクラスは新しい文字列を、Classクラスは新しいクラスを製造する

#### 1.5 まとめ

* アプリケーションが長く続くと、今度は変更が大きな問題になる
    * 効果的な変更を取り入れることができるようにコードを構成することは設計の問題
        * 原則とパターンを正確に適用しても、それで簡単に変更できるとは限らない。

### 第2章 単一責任のクラスを設計する

* メッセージが設計の核になるが、目立つのはクラスである
    * まずはクラスに属するものの決め方について学んでいく
        * シンプルであることを考える
            * クラスを使い、求められる動作をしつつ、簡単に変更できるようにモデル化する
                * テクニック自体はシンプルなので、どのように使うかが重要になる

#### 2.1　クラスに属するものを決める

* コードの書き方はわかるが、どこに置けばいいのかわからない→そこについて学習する

##### メソッドをグループに分けクラスにまとめる

* クラスを作ることは枠組みを作ることで、この枠組みに縛られずに考えることは難しい
* メソッドを正しくグループ分けし、クラスにまとめることはとても重要
* 設計とはアプリの可変性を保つためにあり、完璧を目指すためのものではない。

##### 変更がかんたんなようにコードを組成する

* かんたんに変更できるとは？？
    * 変更の副作用がない
    * 要件の変更が小さいと、コードの変更も相応に小さい
    * 既存のコードは再利用可
    * 一番かんたんな変更方法はコードの追加
        * そのコードも変更が容易である


#### 2.2　単一の責任を持つクラスを作る

* クラスは最小で有用なものであるべき

##### アプリケーションの例:自転車とギア

*  gearクラスから作られるインスタンスは３つのメソッドを備えている(継承は除く)
    * さらにここから車輪も考慮に入れる
        * この追加を入れたことにより、`initialize`に引数が追加になり、追加前に動いていたものが動かなくなる
            * メソッドに必要な引数の数の変更は大きな問題になる

##### なぜ単一責任が重要なのか

* 変更が簡単なアプリは再利用が簡単なクラスから構成
    * 明確な定義からなり、周りとの絡み合いも少ない
* ２つ以上の責任をもつクラスは簡単には再利用できない。
    * 必要な部分だけを手に入れるのは無理である

##### クラスが単一責任かをどう見極める

* どのように「別のどこかに属する振る舞い」を含んでるかを見極めるのか？
    * クラスのもつメソッドを質問に言い換え、意味をなすのか。
        * ex) Gearさん、あなたのタイヤのサイズを教えてください→×
        *     あなたのGearの比は、、、、ok
    * １文でクラスの説明をしてみる

##### 設計を決定する時を見極める

* 将来にどんな機能が追加されるのが完璧にわかるなら、設計も完璧にできる
    * しかしそんなことは起きない
        * その時点で最も費用対効果が高いものを考える
            * ex) 変更する、変更するのを遅らせるなど、、、、

#### 2.3　変更を歓迎するコードを書く

* どんな変更が追加されるがわからないが、変更を受け入れるコードを書くことは可能
    * 追加のコストをかけることなく、コードを改善できる  
        * 変更を受け入れるコードを書くためのテクニックは以下へ、、、、

##### データではなく振る舞いに依存する

* DRYなコードは変更に寛容
    * どんな変更も１箇所で済むため
* オブジェクトはデータをもつ
    * インスタンス変数を直接参照するのか
    * アクセサメソッドで包み隠す方法　→　こちらを使う
* アクセサメソッドを使うことで、データからメソッドへ変わる
* データは隠蔽するべきである

* インスタンス変数に依存はよくないので、複雑なデータ構造への依存はもっとよくない
    * ただ隠蔽すればいいわけではない。 
        * 複雑な構造に依存するとメッセージの送り手はその構造を把握しないといけないため

##### あらゆる箇所を単一責任にする

* 単一責任の概念はクラス以外のコードでも役立つ

* メソッドも単一責任を持つべき
    + 理由は同じく変更も再利用も簡単になるため
    * メソッドも２つ以上責任を持たせないようにする

* メソッドを単一責任にするメリット
    * クラスを明確にする効果がある
    * コメントする必要がなくなる
    * 他の人も複製ではなく再利用するようになる
    * 他のクラスへの移動が簡単になる

#### 2.4　ついに実際のWheelクラスの作成

* 読了

#### 2.5　まとめ

* メンテナンス性の高いクラスは単一責任から作られ
    * 副作用のない変更と、DRYなコードを書けるようになる