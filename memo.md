# オブジェクト指向設計ガイドメモ

## 20200102

### 第1章 オブジェクト指向設計

* オブジェクト指向設計の手法を学ぶにあたり第一の要求されることはその世界に没入すること。
* 設計の失敗の原因はコーディングテクニックではなく、視点の置き方

#### 1.1 設計の賞賛

* オブジェクト指向設計の手法に従うことで、費用対効果の高いソフトウェアを生み出せるだけでなく、楽しく取り組めるコードが実現できる

##### 設計が解決する問題

* 仮にこれから作るアプリが変更することがないアプリなら設計のことを気にする必要はない
    * ただ実際は変化は避けられない
        * この変化が計画に影響を及ぼすので、設計を重要になる
            * 変更が簡単なアプリは書くのも楽しい

##### 変更が困難な理由

* オブジェクト指向設計とは「依存関係を管理すること」
     * オブジェクトが変更を許容できるような形で、依存関係を構成するためのコーディングテクニックである。
        * 依存関係が管理されていないとオブジェクトが互いを知りすぎるので、１つの変更がもう１つへも影響し、そしてそこからさらに影響し、、、

##### 設計の実用的な定義

* 設計が難しい理由の１つは、ずべての問題を２つの要素を抱えている点
    * 今必要なコードを書くだけでなく、未来の変更も受け入れるものを作ること
         * 設計の目的は後にも設計できるようにすることで、最初の目標は変更コストの削減

#### 1.2 設計の道具

##### 設計原則

* オブジェクト指向で有名な５つの原則
    * 単一責任
    * オープンクローズド
    * リスコフの置換
    * インターフェース分離
    * 依存性逆転

 ##### 設計パターン

 * 共通する問題に同じ名前をつけ同じ手法絵で解決することで、曖昧なことが明確になる。
    * コミュニケーションと共同作業ができるようになった
        * ただし、正しく使うことが大事

####　1.3 設計の行為

##### 設計が失敗する原因

* 最初の失敗の原因は設計が十分ではないこと。
* Rubyのような言語では、誰でも動くアプリは作れるが、設計されていないアプリになるため次第に変更ができなくなる。
* 別の失敗は手法は知ってるが、その適用方法がわからない場合
    * 不適切な場所に不適切な設計をしてしまうことも、、、

##### 設計をいつ行うか

* オブジェクト指向設計とは、変更を簡単になるようにコードの構成を考えること
* アジャイルが成功する鍵がシンプルで、柔軟性のあるコードである

##### 設計を判断する

* 設計者の目標は機能あたりのコストが最も低い方法でソフトウェアを書くこと

#### 1.4 簡単な導入

* オブジェクト指向のアプリはオブジェクトとオブジェクトのメッセージから構成される
    * メッセージがより重要

##### 手続き型言語

* 手続き型プログラミングと対比させることで理解が進む
* 手続き型ではデータの種類があらかじめ決められている
    * どんなことができるかは、プログラマーがそのデータ型に対する知識に基づく

##### オブジェクト指向言語

* Rubyはデータと振る舞いを２つの独立したものにわけない
    * その２つをオブジェクトにまとめる
* 文字列のデータ型ではなく、文字列オブジェクトがある
    * 文字列オブジェクトは自身の操作は自身で用意する
        * Rubyに必要なのはオブジェクトがメッセージを送るための方法を用意することだけ
* 例）Stringクラスから作られたインスタンスはどれも同じメソッドを持つがデータは異なる
* Rubyではあらかじめstringなどのクラスが定義されている
    * そのstringクラスもそれ自体がオブジェクト、Classクラスのインスタンス
        * Stringクラスは新しい文字列を、Classクラスは新しいクラスを製造する

#### 1.5 まとめ

* アプリケーションが長く続くと、今度は変更が大きな問題になる
    * 効果的な変更を取り入れることができるようにコードを構成することは設計の問題
        * 原則とパターンを正確に適用しても、それで簡単に変更できるとは限らない。

### 第2章 単一責任のクラスを設計する

* メッセージが設計の核になるが、目立つのはクラスである
    * まずはクラスに属するものの決め方について学んでいく
        * シンプルであることを考える
            * クラスを使い、求められる動作をしつつ、簡単に変更できるようにモデル化する
                * テクニック自体はシンプルなので、どのように使うかが重要になる

#### 2.1　クラスに属するものを決める

* コードの書き方はわかるが、どこに置けばいいのかわからない→そこについて学習する

##### メソッドをグループに分けクラスにまとめる

* クラスを作ることは枠組みを作ることで、この枠組みに縛られずに考えることは難しい
* メソッドを正しくグループ分けし、クラスにまとめることはとても重要
* 設計とはアプリの可変性を保つためにあり、完璧を目指すためのものではない。

##### 変更がかんたんなようにコードを組成する

* かんたんに変更できるとは？？
    * 変更の副作用がない
    * 要件の変更が小さいと、コードの変更も相応に小さい
    * 既存のコードは再利用可
    * 一番かんたんな変更方法はコードの追加
        * そのコードも変更が容易である


#### 2.2　単一の責任を持つクラスを作る

* クラスは最小で有用なものであるべき

##### アプリケーションの例:自転車とギア

*  gearクラスから作られるインスタンスは３つのメソッドを備えている(継承は除く)
    * さらにここから車輪も考慮に入れる
        * この追加を入れたことにより、`initialize`に引数が追加になり、追加前に動いていたものが動かなくなる
            * メソッドに必要な引数の数の変更は大きな問題になる

##### なぜ単一責任が重要なのか

* 変更が簡単なアプリは再利用が簡単なクラスから構成
    * 明確な定義からなり、周りとの絡み合いも少ない
* ２つ以上の責任をもつクラスは簡単には再利用できない。
    * 必要な部分だけを手に入れるのは無理である

##### クラスが単一責任かをどう見極める

* どのように「別のどこかに属する振る舞い」を含んでるかを見極めるのか？
    * クラスのもつメソッドを質問に言い換え、意味をなすのか。
        * ex) Gearさん、あなたのタイヤのサイズを教えてください→×
        *     あなたのGearの比は、、、、ok
    * １文でクラスの説明をしてみる

##### 設計を決定する時を見極める

* 将来にどんな機能が追加されるのが完璧にわかるなら、設計も完璧にできる
    * しかしそんなことは起きない
        * その時点で最も費用対効果が高いものを考える
            * ex) 変更する、変更するのを遅らせるなど、、、、

#### 2.3　変更を歓迎するコードを書く

* どんな変更が追加されるがわからないが、変更を受け入れるコードを書くことは可能
    * 追加のコストをかけることなく、コードを改善できる  
        * 変更を受け入れるコードを書くためのテクニックは以下へ、、、、

##### データではなく振る舞いに依存する

* DRYなコードは変更に寛容
    * どんな変更も１箇所で済むため
* オブジェクトはデータをもつ
    * インスタンス変数を直接参照するのか
    * アクセサメソッドで包み隠す方法　→　こちらを使う
* アクセサメソッドを使うことで、データからメソッドへ変わる
* データは隠蔽するべきである

* インスタンス変数に依存はよくないので、複雑なデータ構造への依存はもっとよくない
    * ただ隠蔽すればいいわけではない。 
        * 複雑な構造に依存するとメッセージの送り手はその構造を把握しないといけないため

##### あらゆる箇所を単一責任にする

* 単一責任の概念はクラス以外のコードでも役立つ

* メソッドも単一責任を持つべき
    + 理由は同じく変更も再利用も簡単になるため
    * メソッドも２つ以上責任を持たせないようにする

* メソッドを単一責任にするメリット
    * クラスを明確にする効果がある
    * コメントする必要がなくなる
    * 他の人も複製ではなく再利用するようになる
    * 他のクラスへの移動が簡単になる

#### 2.4　ついに実際のWheelクラスの作成

* 読了

#### 2.5　まとめ

* メンテナンス性の高いクラスは単一責任から作られ
    * 副作用のない変更と、DRYなコードを書けるようになる

### 第３章　依存関係を管理する

* １つのオブジェクトが全てを知ることはできないので、他のオブジェクトに聞くしかない
* それぞれのメッセージはオブジェクトから発せられる。
* オブジェクトに求められることは
    * 自身が知っているか継承している
    * そのメッセージを知っているオブジェクトを知っている
* ここでは、振る舞いが他のオブジェクトに実装されている場合について、それにアクセスすることについて。
    * アクセスできるということは少なからず依存関係があることなので、管理が重要になる

#### 3.1　依存関係を理解する

* １つのオブジェクトに変更を加えた場合、他のオブジェクトにも変更が必要になる場合、それは片方に依存しているということ。

##### 依存関係を認識する

* オブジェクトに依存関係があるとは以下の場合
    * 他のクラスの名前を知っている
    * self以外のどこかに送ろうとするメッセージの名前を知ってる
    * メッセージが要求する引数を知っている
    * 引数の順番を知っている

* 上記の依存関係は1部の変更により大きく影響を受ける
* アプリでは２つ以上のオブジェクトによる共同作業は当たり前
    * だが、先ほどの例は必要のない依存関係に当たる

* 今回の設計課題は依存関係を管理し、それぞれのクラスがもつ依存を最底限にする
    * クラスが知るべきことは自分の責任に必要なことのみ

##### オブジェクト間の結合

* あるクラスがあるクラスを知れば知るほど依存関係が強くなる
    * 結合が強くなるとも、、、まるで２つで１つのようになる
        * １つに変更を加えたいなら、もう１つも強制的に変更せざる追えないことになる

##### ほかの依存関係

* メッセージチェーンを繋いで遠くのオブジェクトの振る舞いを実行しようとする場合
* コードに対するテストの依存関係

#### 3.2　疎結合なコードをかく

* 依存を減らすテクニックを学ぶ

##### 依存オブジェクトの注入

* 他のクラスに、クラス名で参照しているところは結合を生み出してしまう場所
    * クラス名が変わったら、参照している場所も変更しないといけない
* 他のオブジェクトについて知らなければ知らないほど力を出せる
* 重要なのはオブジェクトのクラスではなく、メッセージである。。

##### 依存を隔離する

* 理想は不必要な依存は全て取り去ってしまうこと。
    * しかし実際には不可能に近い。
        * 依存を除去できないなら隔離するべき
* 外部のクラス名に対する依存をどのように管理するかはアプリに大きな影響を与える
    * 依存するものを常に気に留め注入することを習慣にしていけば、自然と疎結合になる

* 外部へのメッセージに注目する
    * self以外に送られるメッセージのこと
        * このような場合は専用のメソッドにカプセル化する

##### 引数の順番への依存を取り除く

* 引数が必要なメッセージは引数の順番を固定しないといけないという目立たない依存を含む
    * ex) `initialize`によって指定されている、、、。

* 回避する例として、オプションのハッシュを受け取るようにする
    * 順番への依存がなくなる
    * キー名があることで引数に対するドキュメントになる

* 単純にデフォルト引数を追加したいなら`||`nilガードを使う
    * `fetch`を使うこともでき、こちらもよく使える（真偽値を引数にとる場合など）

* 依存しないといけない外部のメソッドが固定順で引数を必要としているなら、そのメソッドを変更はできない
    * その場合はそのコードを隠蔽するようなメソッドを使用し、外部への依存を隔離する。


#### 3.3 依存方向の管理

* 依存関係の方向の決め方について

##### 依存関係の逆転

* 依存関係を逆にすることも１つの案
    * 依存の方向は変化するアプリにおいて未来に大きな影響が出てくる

##### 依存方向の選択

* 自身より変更されないものへ依存することを考える
    * クラスAはクラスBよりも要件が変わりやすい
    * 多くのクラスに依存されたクラスを変更すると影響が大きい
    * 具象クラスは抽象クラスよりも変わる可能性が高い

* アプリのクラスは変更のおきやすさにによって順位付けができる
    * 例えばフレームワークの場合に自身が書いたコードよりも、フレームワーク自体が変更する場合がある

* 具体的なコードへの依存から抽象的なものへの依存へ
    * 抽象は具体より安定していて、抽象元のクラスより安全

* 多くのクラスに依存されたクラスを持つことの影響もしっかり念頭に入れる

#### 3.4 まとめ

* 依存関係の管理はアプリ作成の鍵
    * 変更に強いアプリを作る鍵となる
    * また、変更による副作用も少ない


### 第4章　柔軟なインターフェースをつくる

* オブジェクト指向のアプリはクラスから成り立つが、メッセージによって定義される
    * メッセージは実際の動きを反映する
* 設計はクラスの責任と依存関係を中心に話すことが多い
    * しかし、オブジェクト間のメッセージについても考える必要あり
* オブジェクトのメッセージはインターフェースを通すので、柔軟なインターフェースを作成する必要がある

#### 4.1 インターフェースを理解する

* 自身について晒しすぎているクラスなどは再利用が困難
    * 他のオブジェクトについても知りすぎていると同じく再利用が困難
        * 1つの変更が周囲へ大きな影響を与える
* 互いに最小のことを明らかに、知っていることも最小に

* クラスが何を明らかにするのかが大事になってくる
* どのメッセージがどのオブジェクトに渡せるかが明確になるように
* クラスのメソッドのうち、いくつかは他のクラスから使われることを想定
    * それらのメソッドがパブリックインターフェースとなる
* 複数のクラスにまたがるどの単一クラスからも独立しているものもある

#### 4.2 インターフェースを定義する

* 公開・非公開があるのはそれが効率がいいため
* 内部実装の詳細に関わるようなものはプライベートで。

##### パブリックインターフェース

* 読了

##### プライベートインターフェース

* 読了

##### 責任、依存、そしてインターフェース

* クラスは単一の目的を持つもの
    * そう考えるとクラスのすることは目的を果たすこと
    * パブリックなメソッドは責任の説明の役割
* 変更の可能性が低いところに依存するという考えはクラス内のメソッドにも当てはまる

* パブリックな部分は安定している部分
* プライベートな部分は変化する可能性がある

#### 4.3 パブリックなインターフェースを見つける

* 良いパブリックなインターフェースは想定外の変更に対するコストが下げる
* 良くないものは逆に上げる

##### アプリの例

* 読了

##### 見当をつける

* いきなりコードを書き始めるのは良くない
* かといってテストから書くのは設計などに対する知識、経験が豊富な熟練者だからできるもの
* ドメインオブジェクトとは
    * データと振る舞いを兼ね備えた名詞
        * 大きくて目に見える現実のもので、データベースに反映されるものされるもの
* ドメインオブジェクトは設計に置いて中心になるものではない
    * オブジェクト間で交わされるメッセージに注意する
* ここではまずコードを書かずに設計、相互理解を深める低コストの方法

##### シーケンス図を使う

* オブジェクトとメッセージを実験するための方法がシーケンス図
    * オブジェクトの構成やメッセージの受け渡しの体系を簡単に実験できる
        * 思考を明確にすることもできる

* シーケンス図で示されるものの例
    * オブジェクトとその間で交わされるメッセージ

* 図を使っていくと、「この受けてはこのメッセージに答える責任があるのか」という疑問がわくことも
    * そこを明らかにしていくのがシーケンス図を使う１つのメリット

* メッセージを基にする視点は柔軟なアプリを生み出す


##### 何を頼むのか

* 適切に定義されたパブリックインターフェースを持つ再利用可能なクラスを作る鍵
    * それは送り手の望みを頼むメッセージと、受け手がどのように振る舞うかを伝えるメッセージの違いを理解すること

* オブジェクト間の会話が「どのように」から「何を」に変わった時に起こる副作用としてパブリックインターフェースが小さくなること
    * つまり他から依存されるメソッドが減るので安定する

##### コンテキストの独立を模索する

* オブジェクトが要求するコンテキストによってオブジェクトの再利用の難しさが関わってくる
    * 単純なコンテキストを持つオブジェクトは簡単に使える
* 最も良い状態はオブジェクトがそのコンテキストから完全に独立していること
    * 相手のことを知らずに共同作業できる
* 何を望むのかを考える（どのようにではなく）
    * そこが責任領域になる

##### 他のオブジェクトを信頼する

* オブジェクト指向的であるとは、自分が何を望んでいるかわかるし、相手が自分の担当をしっかりこなすことを信じること
    * メッセージの受け手が適切に行ってくれることを信じる

##### オブジェクトを見つけるためにメッセージを使う

* メソッドを実装をするオブジェクトを特定する
* シーケンス図などを使えば、「まだ定義されていない必要なオブジェクト」を見つける手がかりになる

##### メッセージを基本としたアプリをつくつ

* オブジェクトからメッセージへ注意を変えることでパブリックなインターフェースの上に作られたアプリを設計できる

#### 4.4 一番良いインターフェースを出すコードを書く

* 読了

##### 明示的なインターフェースをつくる

* 設計の目的は簡単に再利用でき、役割も果たし将来にも対応できるコードを書くこと
* Rubyにはprivate,public protectedがある

##### 他のパブリックなインターフェースに敬意を払う

* 他のクラスとの共同作業はパブリックなインターフェースのみを使う
    * 他のクラスのプライベートメソッドを使おうとしているなら再検討する

##### プライベートインターフェースに依存するときは注意深く

* 読了

##### コンテキストを最小限にする

* パブリックメソッドを作るときは送り手が何も知ることなく、求めているものを得られるように
* 他に要求するコンテキストは最小限に


#### 4.5 デメテルの法則

* 読了

##### デメテルを定義する

* 簡単にいうと .(ドット)は１つしか使わないこと

##### 法則を違反することの影響

* 読了

##### 違反を回避する

* 委譲を行うことでドットを避けることができる
    * `delegate`を使うなどの方法がある

##### デメテルに耳を傾ける

* ドットがいくつもあるチェーンメソッドがあるとき、既存のオブジェクトに影響を受けすぎている
    * 「何を」だけでなく「どのように」を知っている
        * 密な結合により１つの変更がまた別の変更を必要としたりする
* パブリックインターフェースが欠けているオブジェクトがあるのではないかというヒントになる

#### 4.6 まとめ

* メッセージのやり取りはパブリックインターフェースを介して行われる
    * メッセージを中心に考える。そして受け手を信頼する

### ダックタイピングでコストを削減する

* オブジェクト指向の設計の目的
    * 変更のコストを下げる(柔軟)
    * メッセージを中心に考える
        * 上記の部分を兼ね備えたのがダックタイピング

#### 5.1 ダックタイピングを理解する

* オブジェクトの使い手はそのクラスを気にする必要はない
    * クラスとはオブジェクトのパブリックインターフェースを獲得するための一つの方法でしかない。
* 重要なのはオブジェクトが何であるのか
* Rubyでは多岐にわたるインターフェースを実装できる
    * ただ１つのインターフェースに応答すると想定する必要はない

##### ダックを見逃す

* メッセージを送るときそのオブジェクトがどのクラスかは気にしない

##### 問題を悪化させる

* 異なる３つのクラスの名前を参照している上に、それぞれに実装されている具体的なメソッドを知っている状態
    * これは１つの変更が他にも影響がでる悪い例
* クラスに基づく視点がもたらした依存が多いコードになると危険
* メソッドが特定のクラス(具象クラス)に依存し、さらにそのクラスの具体的なメソッド名に依存していると柔軟性がないものになる

##### ダックを見つける

* 依存をとる鍵はメソッドは単一の目的を果たすようにすることなので、引数も同じような考えにする
    * どの引数も同じ理由になるように
        * 抽象的に考える

##### ダックタイピングの影響

* 具体と抽象
    * 具体的だど理解はしやすいが拡張にリスクが生じる
    * 抽象的は最初が理解しづらいが、拡張性に優れる

#### 5.2 ダックを信頼するコードをかく

 * ダックタイピングが必要なこと、そのインターフェースを抽象化をすることが難しい

##### 隠れたダックを認識する

* ダックの存在を示唆するコードがある
    * `case`など

##### ダックを信頼する

* 読了

##### ダックタイピングを文書化する

* 単純なダックタイピングは単にパブリックインターフェースの取り決めとしてだけ存在

##### ダック間でコードの共有

* 読了

##### 賢くダックを選ぶ

* 設計の目的とはコストを下げること（ダックタイピングなどのテクニックを使うためのものではない）
* Rubyのコアクラスに依存しているのは比較的安定している
