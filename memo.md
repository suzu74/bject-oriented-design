# オブジェクト指向設計ガイドメモ

## 20200102

### 第1章 オブジェクト指向設計

* オブジェクト指向設計の手法を学ぶにあたり第一の要求されることはその世界に没入すること。
* 設計の失敗の原因はコーディングテクニックではなく、視点の置き方

#### 1.1 設計の賞賛

* オブジェクト指向設計の手法に従うことで、費用対効果の高いソフトウェアを生み出せるだけでなく、楽しく取り組めるコードが実現できる

##### 設計が解決する問題

* 仮にこれから作るアプリが変更することがないアプリなら設計のことを気にする必要はない
    * ただ実際は変化は避けられない
        * この変化が計画に影響を及ぼすので、設計を重要になる
            * 変更が簡単なアプリは書くのも楽しい

##### 変更が困難な理由

* オブジェクト指向設計とは「依存関係を管理すること」
     * オブジェクトが変更を許容できるような形で、依存関係を構成するためのコーディングテクニックである。
        * 依存関係が管理されていないとオブジェクトが互いを知りすぎるので、１つの変更がもう１つへも影響し、そしてそこからさらに影響し、、、

##### 設計の実用的な定義

* 設計が難しい理由の１つは、ずべての問題を２つの要素を抱えている点
    * 今必要なコードを書くだけでなく、未来の変更も受け入れるものを作ること
         * 設計の目的は後にも設計できるようにすることで、最初の目標は変更コストの削減

#### 1.2 設計の道具

##### 設計原則

* オブジェクト指向で有名な５つの原則
    * 単一責任
    * オープンクローズド
    * リスコフの置換
    * インターフェース分離
    * 依存性逆転

 ##### 設計パターン

 * 共通する問題に同じ名前をつけ同じ手法絵で解決することで、曖昧なことが明確になる。
    * コミュニケーションと共同作業ができるようになった
        * ただし、正しく使うことが大事

####　1.3 設計の行為

##### 設計が失敗する原因

* 最初の失敗の原因は設計が十分ではないこと。
* Rubyのような言語では、誰でも動くアプリは作れるが、設計されていないアプリになるため次第に変更ができなくなる。
* 別の失敗は手法は知ってるが、その適用方法がわからない場合
    * 不適切な場所に不適切な設計をしてしまうことも、、、

##### 設計をいつ行うか

* オブジェクト指向設計とは、変更を簡単になるようにコードの構成を考えること
* アジャイルが成功する鍵がシンプルで、柔軟性のあるコードである

##### 設計を判断する

* 設計者の目標は機能あたりのコストが最も低い方法でソフトウェアを書くこと

#### 1.4 簡単な導入

* オブジェクト指向のアプリはオブジェクトとオブジェクトのメッセージから構成される
    * メッセージがより重要

##### 手続き型言語

* 手続き型プログラミングと対比させることで理解が進む
* 手続き型ではデータの種類があらかじめ決められている
    * どんなことができるかは、プログラマーがそのデータ型に対する知識に基づく

##### オブジェクト指向言語

* Rubyはデータと振る舞いを２つの独立したものにわけない
    * その２つをオブジェクトにまとめる
* 文字列のデータ型ではなく、文字列オブジェクトがある
    * 文字列オブジェクトは自身の操作は自身で用意する
        * Rubyに必要なのはオブジェクトがメッセージを送るための方法を用意することだけ
* 例）Stringクラスから作られたインスタンスはどれも同じメソッドを持つがデータは異なる
* Rubyではあらかじめstringなどのクラスが定義されている
    * そのstringクラスもそれ自体がオブジェクト、Classクラスのインスタンス
        * Stringクラスは新しい文字列を、Classクラスは新しいクラスを製造する

#### 1.5 まとめ

* アプリケーションが長く続くと、今度は変更が大きな問題になる
    * 効果的な変更を取り入れることができるようにコードを構成することは設計の問題
        * 原則とパターンを正確に適用しても、それで簡単に変更できるとは限らない。

### 第2章 単一責任のクラスを設計する

* メッセージが設計の核になるが、目立つのはクラスである
    * まずはクラスに属するものの決め方について学んでいく
        * シンプルであることを考える
            * クラスを使い、求められる動作をしつつ、簡単に変更できるようにモデル化する
                * テクニック自体はシンプルなので、どのように使うかが重要になる

#### 2.1　クラスに属するものを決める

* コードの書き方はわかるが、どこに置けばいいのかわからない→そこについて学習する

##### メソッドをグループに分けクラスにまとめる

* クラスを作ることは枠組みを作ることで、この枠組みに縛られずに考えることは難しい
* メソッドを正しくグループ分けし、クラスにまとめることはとても重要
* 設計とはアプリの可変性を保つためにあり、完璧を目指すためのものではない。

##### 変更がかんたんなようにコードを組成する

* かんたんに変更できるとは？？
    * 変更の副作用がない
    * 要件の変更が小さいと、コードの変更も相応に小さい
    * 既存のコードは再利用可
    * 一番かんたんな変更方法はコードの追加
        * そのコードも変更が容易である


#### 2.2　単一の責任を持つクラスを作る

* クラスは最小で有用なものであるべき

##### アプリケーションの例:自転車とギア

*  gearクラスから作られるインスタンスは３つのメソッドを備えている(継承は除く)
    * さらにここから車輪も考慮に入れる
        * この追加を入れたことにより、`initialize`に引数が追加になり、追加前に動いていたものが動かなくなる
            * メソッドに必要な引数の数の変更は大きな問題になる

##### なぜ単一責任が重要なのか

* 変更が簡単なアプリは再利用が簡単なクラスから構成
    * 明確な定義からなり、周りとの絡み合いも少ない
* ２つ以上の責任をもつクラスは簡単には再利用できない。
    * 必要な部分だけを手に入れるのは無理である

##### クラスが単一責任かをどう見極める

* どのように「別のどこかに属する振る舞い」を含んでるかを見極めるのか？
    * クラスのもつメソッドを質問に言い換え、意味をなすのか。
        * ex) Gearさん、あなたのタイヤのサイズを教えてください→×
        *     あなたのGearの比は、、、、ok
    * １文でクラスの説明をしてみる

##### 設計を決定する時を見極める

* 将来にどんな機能が追加されるのが完璧にわかるなら、設計も完璧にできる
    * しかしそんなことは起きない
        * その時点で最も費用対効果が高いものを考える
            * ex) 変更する、変更するのを遅らせるなど、、、、

#### 2.3　変更を歓迎するコードを書く

* どんな変更が追加されるがわからないが、変更を受け入れるコードを書くことは可能
    * 追加のコストをかけることなく、コードを改善できる  
        * 変更を受け入れるコードを書くためのテクニックは以下へ、、、、

##### データではなく振る舞いに依存する

* DRYなコードは変更に寛容
    * どんな変更も１箇所で済むため
* オブジェクトはデータをもつ
    * インスタンス変数を直接参照するのか
    * アクセサメソッドで包み隠す方法　→　こちらを使う
* アクセサメソッドを使うことで、データからメソッドへ変わる
* データは隠蔽するべきである

* インスタンス変数に依存はよくないので、複雑なデータ構造への依存はもっとよくない
    * ただ隠蔽すればいいわけではない。 
        * 複雑な構造に依存するとメッセージの送り手はその構造を把握しないといけないため

##### あらゆる箇所を単一責任にする

* 単一責任の概念はクラス以外のコードでも役立つ

* メソッドも単一責任を持つべき
    + 理由は同じく変更も再利用も簡単になるため
    * メソッドも２つ以上責任を持たせないようにする

* メソッドを単一責任にするメリット
    * クラスを明確にする効果がある
    * コメントする必要がなくなる
    * 他の人も複製ではなく再利用するようになる
    * 他のクラスへの移動が簡単になる

#### 2.4　ついに実際のWheelクラスの作成

* 読了

#### 2.5　まとめ

* メンテナンス性の高いクラスは単一責任から作られ
    * 副作用のない変更と、DRYなコードを書けるようになる

#### 第３章　依存関係を管理する

* １つのオブジェクトが全てを知ることはできないので、他のオブジェクトに聞くしかない
* それぞれのメッセージはオブジェクトから発せられる。
* オブジェクトに求められることは
    * 自身が知っているか継承している
    * そのメッセージを知っているオブジェクトを知っている
* ここでは、振る舞いが他のオブジェクトに実装されている場合について、それにアクセスすることについて。
    * アクセスできるということは少なからず依存関係があることなので、管理が重要になる

#### 3.1　依存関係を理解する

* １つのオブジェクトに変更を加えた場合、他のオブジェクトにも変更が必要になる場合、それは片方に依存しているということ。

##### 依存関係を認識する

* オブジェクトに依存関係があるとは以下の場合
    * 他のクラスの名前を知っている
    * self以外のどこかに送ろうとするメッセージの名前を知ってる
    * メッセージが要求する引数を知っている
    * 引数の順番を知っている

* 上記の依存関係は1部の変更により大きく影響を受ける
* アプリでは２つ以上のオブジェクトによる共同作業は当たり前
    * だが、先ほどの例は必要のない依存関係に当たる

* 今回の設計課題は依存関係を管理し、それぞれのクラスがもつ依存を最底限にする
    * クラスが知るべきことは自分の責任に必要なことのみ

##### オブジェクト間の結合

* あるクラスがあるクラスを知れば知るほど依存関係が強くなる
    * 結合が強くなるとも、、、まるで２つで１つのようになる
        * １つに変更を加えたいなら、もう１つも強制的に変更せざる追えないことになる

##### ほかの依存関係

* メッセージチェーンを繋いで遠くのオブジェクトの振る舞いを実行しようとする場合
* コードに対するテストの依存関係

#### 3.2　疎結合なコードをかく

* 依存を減らすテクニックを学ぶ

##### 依存オブジェクトの注入

* 他のクラスに、クラス名で参照しているところは結合を生み出してしまう場所
    * クラス名が変わったら、参照している場所も変更しないといけない
* 他のオブジェクトについて知らなければ知らないほど力を出せる
* 重要なのはオブジェクトのクラスではなく、メッセージである。。

##### 依存を隔離する

* 理想は不必要な依存は全て取り去ってしまうこと。
    * しかし実際には不可能に近い。
        * 依存を除去できないなら隔離するべき
* 外部のクラス名に対する依存をどのように管理するかはアプリに大きな影響を与える
    * 依存するものを常に気に留め注入することを習慣にしていけば、自然と疎結合になる

* 外部へのメッセージに注目する
    * self以外に送られるメッセージのこと
        * このような場合は専用のメソッドにカプセル化する

##### 引数の順番への依存を取り除く

* 引数が必要なメッセージは引数の順番を固定しないといけないという目立たない依存を含む
    * ex) `initialize`によって指定されている、、、。

* 回避する例として、オプションのハッシュを受け取るようにする
    * 順番への依存がなくなる
    * キー名があることで引数に対するドキュメントになる

* 単純にデフォルト引数を追加したいなら`||`nilガードを使う
    * `fetch`を使うこともでき、こちらもよく使える（真偽値を引数にとる場合など）

* 依存しないといけない外部のメソッドが固定順で引数を必要としているなら、そのメソッドを変更はできない
    * その場合はそのコードを隠蔽するようなメソッドを使用し、外部への依存を隔離する。

